// Includes
#include "common_ps_fxc.h"

const float4x4 Clip[8] : register(c0);
const int ClipSize : register(i0);

struct PS_INPUT
{
	float4 Position		:	POSITION;
	float4 Color		:	COLOR0;
	float2 ObjectCoord	:	TEXCOORD0;
};

float sdRect(float2 p, float2 size)
{
	float2 d = abs(p) - size;
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// The below function "sdEllipse" is MIT licensed with following text:
//
// The MIT License
// Copyright 2013 Inigo Quilez
// Permission is hereby granted, free of charge, to any person obtaining a 
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software
// is furnished to do so, subject to the following conditions: The above copyright
// notice and this permission notice shall be included in all copies or substantial
// portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
// ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
// EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

float sdEllipse(float2 p, float2 ab)
{
	float outVal;

	if (abs(ab.x - ab.y) < 0.1)
	{
		outVal = length(p) - ab.x;
	}
	else
	{
		p = abs(p); if (p.x > p.y) { p = p.yx; ab = ab.yx; }

		float l = ab.y*ab.y - ab.x*ab.x;

		float m = ab.x*p.x / l;
		float n = ab.y*p.y / l;
		float m2 = m*m;
		float n2 = n*n;

		float c = (m2 + n2 - 1.0) / 3.0;
		float c3 = c*c*c;

		float q = c3 + m2*n2*2.0;
		float d = c3 + m2*n2;
		float g = m + m*n2;

		float co;

		if (d < 0.0)
		{
			float p = acos(q / c3) / 3.0;
			float s = cos(p);
			float t = sin(p)*sqrt(3.0);
			float rx = sqrt(-c*(s + t + 2.0) + m2);
			float ry = sqrt(-c*(s - t + 2.0) + m2);
			co = (ry + sign(l)*rx + abs(g) / (rx*ry) - m) / 2.0;
		}
		else
		{
			float h = 2.0*m*n*sqrt(d);
			float s = sign(q + h)*pow(abs(q + h), 1.0 / 3.0);
			float u = sign(q - h)*pow(abs(q - h), 1.0 / 3.0);
			float rx = -s - u - c*4.0 + 2.0*m2;
			float ry = (s - u)*sqrt(3.0);
			float rm = sqrt(rx*rx + ry*ry);
			float p = ry / sqrt(rm - rx);
			co = (p + 2.0*g / rm - m) / 2.0;
		}

		float si = sqrt(1.0 - co*co);

		float2 r = float2(ab.x*co, ab.y*si);

		outVal = length(r - p) * sign(p.y - r.y);
	}

	return outVal;
}

float2 transformAffine(float2 val, float2 a, float2 b, float2 c)
{
	return val.x * a + val.y * b + c;
}

void Unpack(float4 x, out float4 a, out float4 b)
{
	const float s = 65536.0;
	a = floor(x / s);
	b = floor(x - a * s);
}

#define AA_WIDTH 0.354

float antialias(in float d, in float width, in float median)
{
	return smoothstep(median - width, median + width, d);
}

float4 GetCol(in matrix m, int i) { return float4(m[0][i], m[1][i], m[2][i], m[3][i]); }

#define VISUALIZE_CLIP 0

void applyClip(PS_INPUT input, inout float4 outColor)
{
	for (int i = 0; i < ClipSize; i++)
	{
		matrix data = Clip[i];
		float2 origin = GetCol(data, 0).xy;
		float2 size = GetCol(data, 0).zw;
		float4 radii_x, radii_y;
		Unpack(GetCol(data, 1), radii_x, radii_y);
		bool inverse = bool(GetCol(data, 3).z);

		float2 p = input.ObjectCoord;
		p = transformAffine(p, GetCol(data, 2).xy, GetCol(data, 2).zw, GetCol(data, 3).xy);
		p -= origin;
		float d_clip = sdRect(p, size) * (inverse ? -1.0 : 1.0);

#if VISUALIZE_CLIP
		if (abs(d_clip) < 3.0)
		{
			outColor = float4(0.9, 1.0, 0.0, 1.0);
		}
#else
		float alpha = antialias(-d_clip, AA_WIDTH, -AA_WIDTH);
		outColor = float4(outColor.rgb * alpha, outColor.a * alpha);
#endif
	}
}

float4 main(PS_INPUT input) : COLOR
{
	return float4(1.0, 0.0, 0.0, 1.0);
}